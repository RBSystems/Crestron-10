/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name: Crestron Electronics, Inc.
System Name:
System Number:
Programmer: LP/KK
Comments:
*/

/*******************************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*******************************************************************************************/
// #ENABLE_DYNAMIC
#SYMBOL_NAME "Marantz SR-7007 IP v1.1 Processor"
// #HINT ""
// #DEFINE_CONSTANT
// #CATEGORY "0" 
// #PRINT_TO_TRACE
// #DIGITAL_EXPAND 
// #ANALOG_SERIAL_EXPAND 
// #OUTPUT_SHIFT 
// #HELP_PDF_FILE ""
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#ENCODING_ASCII
// #ENCODING_UTF16
// #ENCODING_INHERIT_FROM_PARENT
// #ENCODING_INHERIT_FROM_PROGRAM

#HELP_BEGIN
To be used with the Marantz SR-7007 IP v1.1.umc module only.
Not to be used as a stand-alone module.
#HELP_END


/*******************************************************************************************
  Include Libraries
  (Uncomment and include additional libraries as needed)
*******************************************************************************************/
// #CRESTRON_LIBRARY ""
// #USER_LIBRARY ""

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
// DIGITAL_INPUT 
// ANALOG_INPUT 
// STRING_INPUT 
BUFFER_INPUT From_Device[50000];
DIGITAL_INPUT AM_Selected;
DIGITAL_INPUT FM_Selected;
DIGITAL_INPUT Clear;
DIGITAL_INPUT HD_Tuner_KP[12];
// BUFFER_INPUT Response_NSE[125];		// khk: not used 


DIGITAL_OUTPUT Highlight_Line[8];
STRING_OUTPUT Main_Volume_Text;
ANALOG_OUTPUT Main_Volume_Gauge;
STRING_OUTPUT Zone_2_Volume_Text;
ANALOG_OUTPUT Zone_2_Volume_Gauge;
STRING_OUTPUT Zone_3_Volume_Text;
ANALOG_OUTPUT Zone_3_Volume_Gauge;
STRING_OUTPUT Front_Left_Level_Text;
STRING_OUTPUT Front_Right_Level_Text;
STRING_OUTPUT Center_Level_Text;
STRING_OUTPUT Subwoofer_Level_Text;
STRING_OUTPUT Surround_Left_Level_Text;
STRING_OUTPUT Surround_Right_Level_Text;
STRING_OUTPUT Surround_Back_Left_Level_Text;
STRING_OUTPUT Surround_Back_Right_Level_Text;
STRING_OUTPUT Surround_Back_Level_Text;
STRING_OUTPUT Front_Height_Left_Level_Text;
STRING_OUTPUT Front_Height_Right_Level_Text;
STRING_OUTPUT Front_Wide_Left_Level_Text;
STRING_OUTPUT Front_Wide_Right_Level_Text;
STRING_OUTPUT Tuner_Frequency;
STRING_OUTPUT To_Device;
STRING_OUTPUT Line_Out[9];

/*******************************************************************************************
  SOCKETS
  (Uncomment and define socket definitions as needed)
*******************************************************************************************/
// TCP_CLIENT
// TCP_SERVER
// UDP_SOCKET

/*******************************************************************************************
  Parameters
  (Uncomment and declare parameters as needed)
*******************************************************************************************/
// INTEGER_PARAMETER
// SIGNED_INTEGER_PARAMETER
// LONG_INTEGER_PARAMETER
// SIGNED_LONG_INTEGER_PARAMETER
// STRING_PARAMETER

/*******************************************************************************************
  Parameter Properties
  (Uncomment and declare parameter properties as needed)
*******************************************************************************************/
/*
#BEGIN_PARAMETER_PROPERTIES parameter_variable, parameter_variable, ...
   // propValidUnits = // unitString or unitDecimal|unitHex|unitPercent|unitCharacter|unitTime|unitTicks;
   // propDefaultUnit = // unitString, unitDecimal, unitHex, unitPercent, unitCharacter, unitTime or unitTicks;
   // propBounds = lower_bound , upper_bound;
   // propDefaultValue = ;  // or, propDefaultValue = "";
   // propList = // { "value" , "label" } , { "value" , "label" } , ... ;
   // propShortDescription = "status_bar_hint_text";
   // #BEGIN_PROP_FULL_DESCRIPTION  line_1...  line_2...  line_n  #END_PROP_FULL_DESCRIPTION
   // #BEGIN_PROP_NOTES line_1...  line_2...  line_n  #END_PROP_NOTES
#END_PARAMETER_PROPERTIES
*/

/*******************************************************************************************
  Structure Definitions
  (Uncomment and define structure definitions as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: struct.myString = "";
*******************************************************************************************/
/*
STRUCTURE MyStruct1
{
};

MyStruct1 struct;
*/

/*******************************************************************************************
  Global Variables
  (Uncomment and declare global variables as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: myString = "";
*******************************************************************************************/
INTEGER iProcessFromDevice;
INTEGER iValue;
INTEGER iMVMAX;
INTEGER iStationValue;
INTEGER iSemaphore;
// LONG_INTEGER
// SIGNED_INTEGER
// SIGNED_LONG_INTEGER
STRING sHDTunerNumber[4];
STRING sHDTunerCommand[10];

// LONG_INTEGER
// SIGNED_INTEGER
// SIGNED_LONG_INTEGER
// STRING sFromDevice[5000];	  // khk: not used
STRING sResponseFromDevice[125];  // khk: used specifically for extracted message receieved from CHANGE From_Device
STRING sDump[150];
STRING sSelectedChar[1];
INTEGER iStringNumber;

/*******************************************************************************************
  Functions
  (Add any additional functions here)
  Note:  Functions must be physically placed before the location in
         the code that calls them.
*******************************************************************************************/

String_Function Calculate_Level(INTEGER iValue)
{
	STRING sLevelText[8];

	if(iValue >= 500)				// 0 to 12 dB
		makestring(sLevelText, "%+d.%d dB", (iValue - 500) / 10, (iValue - 500) mod 10);
	else							// -12 to -0.5 dB
		makestring(sLevelText, "-%d.%d dB", (500 - iValue) / 10, (500 - iValue) mod 10); 
    return (sLevelText);
}


/*******************************************************************************************
  Event Handlers
  (Uncomment and declare additional event handlers as needed)
*******************************************************************************************/

PUSH HD_Tuner_KP		// used to send channel number command
{
	INTEGER a;

	switch(getlastmodifiedarrayindex())
	{
		case(1):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s1", sHDTunerNumber);
		}
		case(2):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s2", sHDTunerNumber);
		}
		case(3):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s3", sHDTunerNumber);
		}
		case(4):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s4", sHDTunerNumber);
		}
		case(5):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s5", sHDTunerNumber);
		}
		case(6):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s6", sHDTunerNumber);
		}
		case(7):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s7", sHDTunerNumber);
		}
		case(8):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s8", sHDTunerNumber);
		}
		case(9):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s9", sHDTunerNumber);
		}
		case(10):
		{
			if(len(sHDTunerNumber) < 4)
			makestring(sHDTunerNumber, "%s0", sHDTunerNumber);
		}
		case(11):		// clear
		{
			clearbuffer(sHDTunerNumber);
		}
		case(12):		// send
		{
			if(AM_Selected)
			{
				if(len(sHDTunerNumber) = 3)
					makestring(To_Device, "TFHD0%s00\x0D", sHDTunerNumber);
				else if(len(sHDTunerNumber) = 4)
					makestring(To_Device, "TFHD%s00\x0D", sHDTunerNumber);
			}
			if(FM_Selected)
			{
				if(len(sHDTunerNumber) = 3)
					makestring(To_Device, "TFHD00%s0\x0D", sHDTunerNumber);
				else if(len(sHDTunerNumber) = 4)
					makestring(To_Device, "TFHD0%s0\x0D", sHDTunerNumber);
			}
			clearbuffer(sHDTunerNumber);
		}
	}
	if(len(sHDTunerNumber) > 0)		// if number string exists
	{
		if(AM_Selected)
			makestring(Tuner_Frequency, "%s*", sHDTunerNumber);	// send to text field 
		if(FM_Selected)
			makestring(Tuner_Frequency, "%s.%s*", left(sHDTunerNumber, len(sHDTunerNumber) - 1), right(sHDTunerNumber, 1));	// send to text field 
	}
	else							// if not
		makestring(Tuner_Frequency, "*");		// clear text field
}
             
       

// khk: This function parses the message extracted from CHANGE From_Device
Function ProcessRxMessage_FromDevice()
{
	if(find("MVMAX", sResponseFromDevice) = 1)	// master volume max
	{
		iMVMAX = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 9)			// value has 2 char (90 vs 895) 
			iMVMAX = iMVMAX * 10;		// append "0" to value (900)
	}
	else if(find("MV", sResponseFromDevice) = 1)	// master volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 5)			// value has 2 char (90 vs 895)
			iValue = iValue * 10;		// append "0" to value (900)
		if(iValue >= 800)				// 0 to 18 dB
			makestring(Main_Volume_Text, "%+d.%ddB", (iValue - 800) / 10, (iValue - 800) mod 10);
		else if(iValue >= 5)			// -79.5 to -0.5 dB
			makestring(Main_Volume_Text, "-%d.%ddB", (800 - iValue) / 10, (800 - iValue) mod 10);
		else							// ---
			makestring(Main_Volume_Text, "---.-dB");
		Main_Volume_Gauge = (iValue * 65535) / iMVMAX;
      	}
	else if(find("Z2", sResponseFromDevice) = 1 && byte(sResponseFromDevice, 3) > 47 && byte(sResponseFromDevice, 3) < 58)	// zone 2 volume
	{
		iValue = atoi(mid(sResponseFromDevice, 3, 2));
		if(iValue >= 80)				// 0 to 18 dB
			makestring(Zone_2_Volume_Text, "+%ddB", (iValue - 80));
		else if(iValue >= 1)			// -79 to 1 dB
			makestring(Zone_2_Volume_Text, "-%ddB", (80 - iValue));
		else							// ---
			makestring(Zone_2_Volume_Text, "---dB");
		Zone_2_Volume_Gauge = (iValue * 65535) / 98;
      	}
	else if(find("Z3", sResponseFromDevice) = 1 && byte(sResponseFromDevice, 3) > 47 && byte(sResponseFromDevice, 3) < 58)	// zone 2 volume
	{
		iValue = atoi(mid(sResponseFromDevice, 3, 2));
		if(iValue >= 80)				// 0 to 18 dB
			makestring(Zone_3_Volume_Text, "+%ddB", (iValue - 80));
		else if(iValue >= 1)			// -79 to 1 dB
			makestring(Zone_3_Volume_Text, "-%ddB", (80 - iValue));
		else							// ---
			makestring(Zone_3_Volume_Text, "---dB");
		Zone_3_Volume_Gauge = (iValue * 65535) / 98;
      	}
	else if(find("CVFL", sResponseFromDevice) = 1)// front left volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 8)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Front_Left_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVFR", sResponseFromDevice) = 1)// front right volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 8)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Front_Right_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVC", sResponseFromDevice) = 1)	// center volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 7)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Center_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVSW", sResponseFromDevice) = 1)// subwoofer volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 8)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Subwoofer_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVSL", sResponseFromDevice) = 1)// surround left volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 8)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Surround_Left_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVSR", sResponseFromDevice) = 1)// surround right volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 8)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Surround_Right_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVSBL", sResponseFromDevice) = 1)// surrond back left volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 9)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Surround_Back_Left_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVSBR", sResponseFromDevice) = 1)// surround back right volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 9)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Surround_Back_Right_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVSB", sResponseFromDevice) = 1)// surround back volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 8)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Surround_Back_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVFHL", sResponseFromDevice) = 1)// front height left volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 9)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Front_Height_Left_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVFHR", sResponseFromDevice) = 1)// front height right volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 9)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Front_Height_Right_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVFWL", sResponseFromDevice) = 1)// front wide left volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 9)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Front_Wide_Left_Level_Text = Calculate_Level(iValue);
      	}
	else if(find("CVFWR", sResponseFromDevice) = 1)// front wide right volume
	{
		iValue = atoi(sResponseFromDevice);
		if(len(sResponseFromDevice) = 9)			// value has 2 char (50 vs 495)
			iValue = iValue * 10;		// append "0" to value (500)
		Front_Wide_Right_Level_Text = Calculate_Level(iValue);
      	}

	else if(find("NSE", sResponseFromDevice) = 1)
	{
    	sDump = Remove("NSE", sResponseFromDevice);
		iStringNumber = atoi(sResponseFromDevice);
		sDump = removebylength(1, sResponseFromDevice);
		if(iStringNumber = 0 || iStringNumber = 8)
		{
			sDump = Left(sResponseFromDevice, Find("\x0D", sResponseFromDevice));
			sDump = left(sDump, find("\x00", sDump) - 1);
        	Line_Out[iStringNumber + 1] = sDump;
		}
		else
		{
        	sSelectedChar = removebylength(1, sResponseFromDevice);

			if(bit(sSelectedChar, 1, 3) = 0)
				Highlight_Line[iStringNumber + 1] = 0;

			if(bit(sSelectedChar, 1, 3))
			{
				Highlight_Line[iStringNumber + 1] = 1;
            }
			sDump = left(sResponseFromDevice, find("\x0D", sResponseFromDevice) - 1);
			sDump = left(sDump, find("\x00", sDump) - 1);
        	Line_Out[iStringNumber + 1] = sDump;
		}
	}
}

           
// khk: Create seperate 3-Series and 2-Series handlers
#IF_SERIES3
THREADSAFE CHANGE From_Device
{
    while(1)
    {
        try
        {
			// extract message from BUFFER_INPUT stream
            sResponseFromDevice = gather("\x0D", From_Device);
			// now process it
            ProcessRxMessage_FromDevice();
        }
        catch
        {
            // print out a message to the log
            generateuserwarning("CHANGE From_Device: Error encountered in BUFFER_INPUT");
        }
    }
}
#ELSE
CHANGE From_Device
{
	if(iProcessFromDevice = 0)
	{
		iProcessFromDevice = 1;
		while(find("\x0D", From_Device))
		{
			sResponseFromDevice = remove("\x0D", From_Device);
            ProcessRxMessage_FromDevice();
		}
		iProcessFromDevice = 0;
	}
}
#ENDIF
     

        




/*******************************************************************************************
  Main()
  Uncomment and place one-time startup code here
  (This code will get called when the system starts up)
*******************************************************************************************/

Function Main()
{
	iProcessFromDevice = 0;
	iSemaphore = 0;
	iMVMAX = 65535;
}
