// Compiler Directives
#SYMBOL_NAME "Yamaha YXC - Basic"
#CATEGORY "28" // Receiver/Processor
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE

// Constants
#DEFINE_CONSTANT BUFFER_SIZE			1024
#DEFINE_CONSTANT MAX_PAIR_LENGTH		64
#DEFINE_CONSTANT MAX_KV_LENGTH			32
#DEFINE_CONSTANT SHORT_DELAY			5
#DEFINE_CONSTANT LONG_DELAY				50
#DEFINE_CONSTANT MAX_INPUT				4

#DEFINE_CONSTANT END_BRACKET			"}"
#DEFINE_CONSTANT COMMA					","
#DEFINE_CONSTANT COLON					":"

#DEFINE_CONSTANT POWER_KEY				"power"
#DEFINE_CONSTANT VOLUME_KEY				"volume"
#DEFINE_CONSTANT MUTE_KEY				"mute"
#DEFINE_CONSTANT INPUT_KEY				"input"

#DEFINE_CONSTANT ON_VALUE				"on"
#DEFINE_CONSTANT STANDBY_VALUE			"standby"

#DEFINE_CONSTANT TRUE_VALUE				"true"
#DEFINE_CONSTANT FALSE_VALUE			"false"

#DEFINE_CONSTANT HDMI_1_VALUE			"hdmi1"
#DEFINE_CONSTANT HDMI_2_VALUE			"hdmi2"
#DEFINE_CONSTANT HDMI_3_VALUE			"hdmi3"
#DEFINE_CONSTANT HDMI_4_VALUE			"hdmi4"

// Inputs            
DIGITAL_INPUT Connection_FB;
DIGITAL_INPUT _SKIP_;
BUFFER_INPUT Rx$[BUFFER_SIZE];

// Outputs
DIGITAL_OUTPUT Power_On_FB, Power_Off_FB;
DIGITAL_OUTPUT _SKIP_;
DIGITAL_OUTPUT Mute_On_FB, Mute_Off_FB;
DIGITAL_OUTPUT _SKIP_;
DIGITAL_OUTPUT Input_None_FB, Input_FB[4];
DIGITAL_OUTPUT _SKIP_;
ANALOG_OUTPUT Input#_FB, Volume#_FB;

INTEGER gSelectedInput;

FUNCTION SetInputFB(INTEGER _input)
{
	INTEGER i;
    
	Input_None_FB = 0;

	for (i = 1 to MAX_INPUT) Input_FB[i] = 0;

	if (_input = 0) Input_None_FB = 1;
	else Input_FB[_input] = 1;

	Input#_FB = _input;
}

// Functions
FUNCTION HandlePair(STRING _singlePair)
{
	STRING key[MAX_KV_LENGTH];

	key = Remove(COLON, _singlePair);

	if (len(key) = 0)
	{
		trace("Nie znaleziono klucza (brak :)");
		return;
	}

	if (find(POWER_KEY, key) <> 0)
	{

		if (find(ON_VALUE, _singlePair) <> 0)
		{
			Power_Off_FB = 0;
			Power_On_FB = 1;
		}
		else if (find(STANDBY_VALUE, _singlePair) <> 0)
		{
			Power_On_FB = 0;
			Power_Off_FB = 1;
		}
		else trace("Nieobslugiwana wartosc klucza POWER: %s", _singlePair);

	}
	else if (find(MUTE_KEY, key) <> 0)
	{

		if (find(TRUE_VALUE, _singlePair) <> 0)
		{
			Mute_Off_FB = 0;
			Mute_On_FB = 1;
		}
		else if (find(FALSE_VALUE, _singlePair) <> 0)
		{
			Mute_On_FB = 0;
			Mute_Off_FB = 1;
		}
		else trace("Nieobslugiwana wartosc klucza MUTE: %s", _singlePair);

	}
	else if (find(INPUT_KEY, key) <> 0)
	{

		if (find(HDMI_1_VALUE, _singlePair) <> 0)
		{
			SetInputFB(1);
		}
		else if (find(HDMI_2_VALUE, _singlePair) <> 0)
		{
			SetInputFB(2);
		}
		else if (find(HDMI_3_VALUE, _singlePair) <> 0)
		{
			SetInputFB(3);
		}
		else if (find(HDMI_4_VALUE, _singlePair) <> 0)
		{
			SetInputFB(4);
		}
		else
		{
			trace("Nieobslugiwana wartosc klucza INPUT: %s", _singlePair);
			SetInputFB(0);
		}

	}
	else if (find(VOLUME_KEY, key) <> 0)
	{
		Volume#_FB = atoi(_singlePair);
	}

}

// Events
THREADSAFE CHANGE Rx$
{
	STRING singlePacket[BUFFER_SIZE];
	STRING singlePair[MAX_PAIR_LENGTH];
        
	while(1)
    {

		if (connection_FB = 0) break;

		try
		{
			// Wyciecie z bufora pojedynczego pakietu
			singlePacket = Gather(END_BRACKET, Rx$); // Ewentualnie sprobowac z COMMA

			while (len(singlePacket) > 0)
			{
				singlePair = Remove(COMMA, singlePacket);

				if (len(singlePair) = 0) break;

				HandlePair(singlePair);
			}
		}
		catch
		{
			Trace("RX processing exception: %s", GetExceptionMessage());
		}
    
	}
}

// Main function
Function Main()
{
	WaitForInitializationComplete();
}
