//Compiler Directives
#CATEGORY "41" // Remote System Interface
#SYMBOL_NAME "SATEL_INT-RS_Processor"
#HINT ""
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE

// Constants
#DEFINE_CONSTANT BUFFER_SIZE 512
#DEFINE_CONSTANT MAX_FRAME_SIZE 128

#DEFINE_CONSTANT INPUTS_COUNT 256
#DEFINE_CONSTANT ZONES_COUNT 32
#DEFINE_CONSTANT PULSE_TIME 5
#DEFINE_CONSTANT DELAY_TIME 10
#DEFINE_CONSTANT INTERVAL 100

#DEFINE_CONSTANT MAX_ATTEMPTS 3

#DEFINE_CONSTANT FRAME_START "\xFE\xFE"
#DEFINE_CONSTANT FRAME_END "\xFE\x0D"

#DEFINE_CONSTANT SPECIAL_FE "\xFE"
#DEFINE_CONSTANT SPECIAL_F0 "\xF0"
#DEFINE_CONSTANT SPECIAL_FEF0 "\xFE\xF0"

#DEFINE_CONSTANT SPECIAL_FE_INT	0xFE

#DEFINE_CONSTANT INPUTS_QUERY_FRAME "\xFE\xFE\x00\x00\x50\x8A\xFE\x0D"
#DEFINE_CONSTANT ZONES_QUERY_FRAME "\xFE\xFE\x0A\xD7\xEC\xFE\x0D"

#DEFINE_CONSTANT CMD_INPUTS_QUERY "\x00"
#DEFINE_CONSTANT CMD_ZONES_QUERY "\x0A"

#DEFINE_CONSTANT CMD_ZONES_ARM "\x80"
#DEFINE_CONSTANT CMD_ZONES_DISARM "\x84"

// Inputs
DIGITAL_INPUT enable, _SKIP_, tcp_Connected_FB;
DIGITAL_INPUT _SKIP_;
BUFFER_INPUT Rx$[BUFFER_SIZE];
BUFFER_INPUT testIn$[BUFFER_SIZE];

// Outputs
DIGITAL_OUTPUT tcp_Connect, tcp_Disconnect, _SKIP_;
DIGITAL_OUTPUT input_FB[INPUTS_COUNT];
DIGITAL_OUTPUT _SKIP_;
DIGITAL_OUTPUT zone_FB[ZONES_COUNT, ZONES_COUNT];
DIGITAL_OUTPUT _SKIP_;
STRING_OUTPUT Tx$;
STRING_OUTPUT testOut$;

// Global Variables
INTEGER gConnectAttemptCounter;
INTEGER gReceiveAttemptCounter;

STRING_FUNCTION CalculateCRC(STRING _data)
{
	STRING crcString[2];
	INTEGER crc;
	INTEGER dataSize;
	INTEGER i;

	crc = 0x147A;
	dataSize = len(_data);
    
	trace("CRC - Initial value = %X", crc);

	for (i = 1 to dataSize)
	{
		crc = rotateLeft(crc, 1);
		trace("CRC - Byte %u - Step 1 = %X", i, crc);
		crc = crc ^ 0xFFFF;
		trace("CRC - Byte %u - Step 2 = %X", i, crc);
		crc = crc + high(crc) + byte(_data, i);
		trace("CRC - Byte %u - Step 3 = %X", i, crc);
		delay(10);
	}
	
	crcString = chr(high(crc)) + chr(low(crc));

	return(crcString);
}

// Functions

STRING_FUNCTION CreateFrame(STRING _data)
{
	STRING frame[MAX_FRAME_SIZE];
	INTEGER frameSize;    
	INTEGER byteIndex;    

	frame = _data + CalculateCRC(_data);
	frameSize = len(frame);

	for (byteIndex = 1 to frameSize)
	{
		if (byte(frame, byteIndex) = SPECIAL_FE_INT)
		{
			frame = left(frame, byteIndex) + SPECIAL_F0 + right(frame, frameSize - byteIndex);
			frameSize = frameSize + 1;
			byteIndex = byteIndex +1;
        }
	}
	
	frame = FRAME_START + frame + FRAME_END;
	
	return(frame);
}

/*
0x80 arm in mode 0:

+ 8 bytes - user code (with prefix, if required by INTEGRA), e.g.:

if code is '1234', no prefixes: 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
if code is '1234', prefix is '97': 0x97, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF

+ 4 bytes - partition list, e.g.:

if partition 1, 2, and 29 have to be armed: 0x03, 0x00, 0x00, 0x10

Function should return the following codes (see the 0xEF command for details):

0x00 - ok
0x01 - requesting user code not found
0x11 - can not arm, but can use force arm
0x12 - can not arm

*/

/*
- Co z prefixem?
- Kod ma od 4 do 8 cyfr
- Czy jesli kod ma 5 cyfr (np 12345) to (0x12, 0x34, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF) ?
*/
STRING_FUNCTION CreateZoneArmFrame(INTEGER _zoneId, STRING _userCode)
{
	STRING data[13];

	data = CMD_ZONES_ARM;

	return (CreateFrame(data));
}

FUNCTION Disconnect()
{
	trace("Disconnecting...");
	PULSE(PULSE_TIME, tcp_Disconnect);
}

INTEGER_FUNCTION Connect()
{
	trace("Connecting...");

    gConnectAttemptCounter = 1;

	PULSE(PULSE_TIME, tcp_Connect);
    DELAY(DELAY_TIME);

	while (tcp_Connected_FB = 0 && gConnectAttemptCounter <= MAX_ATTEMPTS)
	{
		gConnectAttemptCounter = gConnectAttemptCounter + 1;
		DELAY(DELAY_TIME);
	}

	if (gConnectAttemptCounter > MAX_ATTEMPTS)
	{
		trace("Connecting failed after %u attempts.", MAX_ATTEMPTS);

		Disconnect();
		// TODO : Connection failure
		return (0);
	}
    
	trace("Connection established after %u attempt", gConnectAttemptCounter);

	return (1);	
}

STRING_FUNCTION ExtractData(STRING _frame)
{	
	STRING extractedData[MAX_FRAME_SIZE];

    INTEGER dataSize;
	INTEGER specialPosition;

	trace("Extracting data...");
    
    dataSize = len(_frame) - 4;	
	extractedData = mid(_frame, 3, dataSize);    
	specialPosition = find(SPECIAL_FEF0, extractedData);

	while (specialPosition > 0)
	{
		trace("Replacing special FEF0 with FE...");

		extractedData = left(extractedData, specialPosition) + right(extractedData, dataSize - specialPosition - 1);
		dataSize = dataSize - 1;
		specialPosition = find(SPECIAL_FEF0, extractedData);
	}

	extractedData = left(extractedData, dataSize - 2);
	
	trace("Data extracted successfully");

	return(extractedData);
}

FUNCTION HandleData(STRING _data)
{
	STRING commandByte[1];
	STRING dataBytes[MAX_FRAME_SIZE];
	INTEGER dataBytesCount;

	INTEGER byteIndex, bitIndex, signalIndex;
    
	trace("Handling data...");

	if (find("ERR", _data) = 1)
	{
		trace("Cannot handle data. %s", _data);
		return;
	}

	commandByte = left(_data, 1);
	dataBytesCount = len(_data) - 1;
	dataBytes = right(_data, dataBytesCount);

	if (commandByte = CMD_INPUTS_QUERY)
	{
		trace("Handling inputs...");

		for (byteIndex = 1 to dataBytesCount)
			for (bitIndex = 0 to 7)
			{
				signalIndex = 8*(byteIndex - 1) + bitIndex + 1;
				input_FB[signalIndex] = bit(dataBytes, byteIndex, bitIndex);
			}
	}
	else if (commandByte = CMD_ZONES_QUERY)
	{
		trace("Handling zones...");

		for (byteIndex = 1 to dataBytesCount)
			for (bitIndex = 0 to 7)
			{
				signalIndex = 8*(byteIndex - 1) + bitIndex + 1;
				zone_FB[signalIndex] = bit(dataBytes, byteIndex, bitIndex);
			}
	}

}

STRING_FUNCTION SendAndReceive(STRING _frameToSend)
{
	STRING receivedFrame[MAX_FRAME_SIZE];

	trace("Sending frame...");

	gReceiveAttemptCounter = 1;	
	Tx$ = _frameToSend;

	trace("Frame sent. Waiting for answer...");    

	delay(DELAY_TIME);
	
	while (len(Rx$) = 0 && gReceiveAttemptCounter <= MAX_ATTEMPTS)
	{
		gReceiveAttemptCounter = gReceiveAttemptCounter + 1;
		DELAY(DELAY_TIME);
	}

	if (gReceiveAttemptCounter > MAX_ATTEMPTS)
	{
		trace("Receiving answer failed after %u attempts", MAX_ATTEMPTS);
		// TODO : Receive failure
		return ("ERR - No answer");
	}
    
	trace("Answer received after %u attempt", gReceiveAttemptCounter);

	if (find(FRAME_START, Rx$) <> 1 || find(FRAME_END, Rx$) = 0)
	{
		trace("Frame format invalid!");
		// TODO : Frame failure
		return ("ERR - Frame format invalid");
	}

	receivedFrame = remove(FRAME_END, Rx$);
	clearbuffer(Rx$);
	
    return (ExtractData(receivedFrame));
}

FUNCTION ClearAll()
{
	INTEGER i;
    
	trace("Clearing all...");

	for (i = 1 to INPUTS_COUNT)
	{
		input_FB[i] = 0;

		if (i <= ZONES_COUNT) zone_FB[i] = 0;
	}
}

FUNCTION Start()
{
	do
	{
		trace("Starting communications...");
	}
	until (Connect() = 1 || enable = 0);
	
	while (enable = 1)
	{		
		if (tcp_Connected_FB = 1)
		{
			HandleData(SendAndReceive(INPUTS_QUERY_FRAME));
			HandleData(SendAndReceive(ZONES_QUERY_FRAME));
			// TODO : j.w. dla kolejki
		}
		else
		{
			do
			{
				trace("Restarting communications...");
			}
			until (Connect() = 1 || enable = 0);
		}
		
		DELAY(INTERVAL);		
	}

	Disconnect();
	
	ClearAll();

	trace("Communications stopped.");
}

// Event Handlers
PUSH enable
{
	Start();
}

CHANGE testIn$
{
	testOut$ = createFrame(testIn$);
	clearBuffer(testIn$);
}

// Main Function
Function Main()
{
	WaitForInitializationComplete();
	// TODO Init
}
